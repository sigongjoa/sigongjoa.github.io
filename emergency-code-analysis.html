<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>응급구조 수요 예측 - 코드 분석 | 서재용</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            theme: { 
                extend: { 
                    colors: { 
                        primary: '#1F3A93',
                        'code-bg': '#1e1e1e',
                        'code-sidebar': '#252526',
                        'code-active': '#094771'
                    } 
                } 
            }
        }
        console.log("ERROR: emergency_code_analysis.js:line_12 - IDE 스타일 코드 분석 페이지 로드됨");
    </script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/vs2015.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
</head>
<body class="bg-code-bg text-gray-100 font-mono">
    <!-- Header -->
    <header class="bg-code-sidebar border-b border-gray-700 px-6 py-3">
        <div class="flex items-center justify-between">
            <div class="flex items-center space-x-4">
                <h1 class="text-lg font-semibold text-white">응급구조 수요 예측 - 코드 분석</h1>
                <span class="text-xs text-gray-400">TFT 모델 기반 시공간 데이터 학습</span>
            </div>
            <div class="flex items-center space-x-4">
                <button onclick="searchFiles()" class="text-gray-400 hover:text-white text-sm">
                    Ctrl+P 파일 검색
                </button>
                <a href="emergency-forecast.html" class="text-blue-400 hover:text-blue-300 text-sm">
                    ← 프로젝트로 돌아가기
                </a>
            </div>
        </div>
    </header>

    <div class="flex h-screen">
        <!-- Sidebar: Project File Tree -->
        <div class="SidebarContainer w-80 bg-code-sidebar border-r border-gray-700 overflow-y-auto">
            <div class="SidebarHeader p-4 border-b border-gray-700">
                <h2 class="text-sm font-semibold text-gray-300 uppercase tracking-wide">
                    📁 응급구조 수요 예측 프로젝트
                </h2>
            </div>
            
            <div class="FileTreeContainer p-2">
                <!-- Main Project Files -->
                <div class="FileTreeLevel1">
                    <div class="FolderItem cursor-pointer hover:bg-gray-700 p-2 rounded" onclick="toggleFolder('src')">
                        <span class="text-yellow-400">📂</span>
                        <span class="ml-2 text-gray-300">src/</span>
                    </div>
                    <div id="src-folder" class="FolderContent ml-4">
                        <div class="FileItem cursor-pointer hover:bg-gray-700 p-1 rounded text-sm" onclick="loadFile('main.py')">
                            <span class="text-blue-400">🐍</span>
                            <span class="ml-2 text-gray-300">main.py</span>
                        </div>
                        <div class="FileItem cursor-pointer hover:bg-gray-700 p-1 rounded text-sm" onclick="loadFile('emergency_data_processor.py')">
                            <span class="text-blue-400">🐍</span>
                            <span class="ml-2 text-gray-300">emergency_data_processor.py</span>
                        </div>
                        <div class="FileItem cursor-pointer hover:bg-gray-700 p-1 rounded text-sm" onclick="loadFile('tft_model.py')">
                            <span class="text-blue-400">🐍</span>
                            <span class="ml-2 text-gray-300">tft_model.py</span>
                        </div>
                        <div class="FileItem cursor-pointer hover:bg-gray-700 p-1 rounded text-sm" onclick="loadFile('spatial_features.py')">
                            <span class="text-blue-400">🐍</span>
                            <span class="ml-2 text-gray-300">spatial_features.py</span>
                        </div>
                        <div class="FileItem cursor-pointer hover:bg-gray-700 p-1 rounded text-sm" onclick="loadFile('weather_integration.py')">
                            <span class="text-blue-400">🐍</span>
                            <span class="ml-2 text-gray-300">weather_integration.py</span>
                        </div>
                        <div class="FileItem cursor-pointer hover:bg-gray-700 p-1 rounded text-sm" onclick="loadFile('visualization.py')">
                            <span class="text-blue-400">🐍</span>
                            <span class="ml-2 text-gray-300">visualization.py</span>
                        </div>
                        <div class="FileItem cursor-pointer hover:bg-gray-700 p-1 rounded text-sm" onclick="loadFile('model_evaluation.py')">
                            <span class="text-blue-400">🐍</span>
                            <span class="ml-2 text-gray-300">model_evaluation.py</span>
                        </div>
                    </div>
                </div>

                <!-- Data Processing -->
                <div class="FileTreeLevel1">
                    <div class="FolderItem cursor-pointer hover:bg-gray-700 p-2 rounded" onclick="toggleFolder('data')">
                        <span class="text-yellow-400">📂</span>
                        <span class="ml-2 text-gray-300">data/</span>
                    </div>
                    <div id="data-folder" class="FolderContent ml-4 hidden">
                        <div class="FileItem cursor-pointer hover:bg-gray-700 p-1 rounded text-sm" onclick="loadFile('data_loader.py')">
                            <span class="text-blue-400">🐍</span>
                            <span class="ml-2 text-gray-300">data_loader.py</span>
                        </div>
                        <div class="FileItem cursor-pointer hover:bg-gray-700 p-1 rounded text-sm" onclick="loadFile('preprocessing.py')">
                            <span class="text-blue-400">🐍</span>
                            <span class="ml-2 text-gray-300">preprocessing.py</span>
                        </div>
                    </div>
                </div>

                <!-- Configuration -->
                <div class="FileTreeLevel1">
                    <div class="FolderItem cursor-pointer hover:bg-gray-700 p-2 rounded" onclick="toggleFolder('config')">
                        <span class="text-yellow-400">📂</span>
                        <span class="ml-2 text-gray-300">config/</span>
                    </div>
                    <div id="config-folder" class="FolderContent ml-4 hidden">
                        <div class="FileItem cursor-pointer hover:bg-gray-700 p-1 rounded text-sm" onclick="loadFile('settings.py')">
                            <span class="text-blue-400">🐍</span>
                            <span class="ml-2 text-gray-300">settings.py</span>
                        </div>
                        <div class="FileItem cursor-pointer hover:bg-gray-700 p-1 rounded text-sm" onclick="loadFile('requirements.txt')">
                            <span class="text-green-400">📄</span>
                            <span class="ml-2 text-gray-300">requirements.txt</span>
                        </div>
                    </div>
                </div>

                <!-- Notebooks -->
                <div class="FileTreeLevel1">
                    <div class="FolderItem cursor-pointer hover:bg-gray-700 p-2 rounded" onclick="toggleFolder('notebooks')">
                        <span class="text-yellow-400">📂</span>
                        <span class="ml-2 text-gray-300">notebooks/</span>
                    </div>
                    <div id="notebooks-folder" class="FolderContent ml-4 hidden">
                        <div class="FileItem cursor-pointer hover:bg-gray-700 p-1 rounded text-sm" onclick="loadFile('eda.ipynb')">
                            <span class="text-orange-400">📓</span>
                            <span class="ml-2 text-gray-300">eda.ipynb</span>
                        </div>
                        <div class="FileItem cursor-pointer hover:bg-gray-700 p-1 rounded text-sm" onclick="loadFile('model_training.ipynb')">
                            <span class="text-orange-400">📓</span>
                            <span class="ml-2 text-gray-300">model_training.ipynb</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Editor Area -->
        <div class="EditorContainer flex-1 flex flex-col">
            <!-- Tab Bar -->
            <div class="TabBar bg-code-sidebar border-b border-gray-700 px-4 py-2">
                <div class="flex space-x-2">
                    <div id="active-tab" class="bg-code-active text-white px-4 py-1 rounded-t text-sm">
                        main.py
                    </div>
                </div>
            </div>

            <!-- Editor Content -->
            <div class="EditorContent flex-1 overflow-auto">
                <div class="LineNumbers bg-gray-800 text-gray-500 text-xs leading-6 p-4 float-left min-w-12 text-right">
                    <div id="line-numbers">1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>14<br>15<br>16<br>17<br>18<br>19<br>20<br>21<br>22<br>23<br>24<br>25<br>26<br>27<br>28<br>29<br>30<br>31<br>32<br>33<br>34<br>35<br>36<br>37<br>38<br>39<br>40<br>41<br>42<br>43<br>44<br>45<br>46<br>47<br>48<br>49<br>50<br>51<br>52<br>53<br>54<br>55<br>56<br>57<br>58<br>59<br>60<br>61<br>62<br>63<br>64<br>65<br>66<br>67<br>68<br>69<br>70<br>71<br>72<br>73<br>74<br>75<br>76<br>77<br>78<br>79<br>80<br>81<br>82<br>83<br>84<br>85<br>86<br>87<br>88<br>89<br>90</div>
                </div>
                <div class="CodeArea flex-1 p-4 overflow-x-auto">
                    <pre id="code-display" class="text-sm leading-6"><code class="python" id="code-content">"""
지능형 구급수요 예측시스템 메인 모듈
시공간 데이터 학습을 이용한 딥러닝 기반 교통사고 위험 예측

Author: 서재용
Project: 강원도 소방본부 응급구조 수요 예측
Date: 2021-2023
"""

import sys
import os
import pandas as pd
import numpy as np
import torch
import warnings
from datetime import datetime
from pathlib import Path

# 프로젝트 모듈 임포트
from src.emergency_data_processor import EmergencyDataProcessor
from src.tft_model import EmergencyDemandPredictor
from src.spatial_features import SpatialFeatureExtractor
from src.weather_integration import WeatherDataIntegrator
from src.visualization import EmergencyAnalyzer
from src.model_evaluation import ModelEvaluator
from config.settings import CONFIG

# 경고 메시지 숨기기
warnings.filterwarnings('ignore')

# 디버그 로깅 설정
import logging
logging.basicConfig(level=logging.ERROR, format='ERROR: %(name)s:line_%(lineno)d - %(message)s')
logger = logging.getLogger(__name__)

class EmergencyForecastSystem:
    """응급구조 수요 예측 시스템 메인 클래스"""
    
    def __init__(self):
        self.config = CONFIG
        self.data_processor = EmergencyDataProcessor()
        self.spatial_extractor = SpatialFeatureExtractor()
        self.weather_integrator = WeatherDataIntegrator()
        self.predictor = EmergencyDemandPredictor(
            max_encoder_length=self.config['model']['encoder_length'],
            max_prediction_length=self.config['model']['prediction_length']
        )
        self.analyzer = EmergencyAnalyzer()
        self.evaluator = ModelEvaluator()
        
        logger.error("응급구조 수요 예측 시스템 초기화 완료")
        
    def load_and_process_data(self):
        """데이터 로드 및 전처리"""
        logger.error("데이터 로드 시작")
        
        # 강원도 소방일지 데이터 로드
        fire_data = self.data_processor.load_fire_department_data(
            self.config['data']['fire_department_path']
        )
        
        # 공간적 특성 추가
        fire_data = self.spatial_extractor.add_spatial_features(fire_data)
        
        # 날씨 데이터 통합
        fire_data = self.weather_integrator.integrate_weather_data(
            fire_data, self.config['data']['weather_path']
        )
        
        # 시계열 특성 생성
        processed_data = self.data_processor.create_time_series_features(fire_data)
        
        logger.error(f"데이터 전처리 완료 - 총 {len(processed_data)}개 레코드")
        return processed_data
        
    def train_model(self, data):
        """TFT 모델 학습"""
        logger.error("TFT 모델 학습 시작")
        
        # 훈련/검증 데이터 분할
        train_data = data[data['date'] < self.config['data']['split_date']]
        val_data = data[data['date'] >= self.config['data']['split_date']]
        
        # 시계열 데이터셋 생성
        training_dataset = self.predictor.create_dataset(train_data)
        validation_dataset = self.predictor.create_dataset(val_data)
        
        # 데이터로더 생성
        train_dataloader = training_dataset.to_dataloader(
            train=True, batch_size=self.config['model']['batch_size']
        )
        val_dataloader = validation_dataset.to_dataloader(
            train=False, batch_size=self.config['model']['batch_size']
        )
        
        # TFT 모델 구축 및 학습
        model = self.predictor.build_model(training_dataset)
        trainer = self.predictor.train_model(
            train_dataloader, val_dataloader, 
            max_epochs=self.config['model']['max_epochs']
        )
        
        logger.error("TFT 모델 학습 완료")
        return model, trainer, validation_dataset

def main():
    """메인 실행 함수"""
    logger.error("응급구조 수요 예측 시스템 시작")
    
    # 시스템 초기화
    system = EmergencyForecastSystem()
    
    # 데이터 로드 및 전처리
    data = system.load_and_process_data()
    
    # 모델 학습
    model, trainer, val_dataset = system.train_model(data)
    
    # 모델 평가
    predictions = system.predictor.predict_emergency_demand(val_dataset)
    metrics = system.evaluator.evaluate_predictions(predictions, val_dataset)
    
    # 결과 시각화
    system.analyzer.create_comprehensive_report(predictions, metrics)
    
    logger.error("응급구조 수요 예측 시스템 실행 완료")
    print("🚀 응급구조 수요 예측 시스템이 성공적으로 실행되었습니다!")

if __name__ == "__main__":
    main()
</code></pre>
                </div>
            </div>
        </div>
    </div>

    <!-- Status Bar -->
    <div class="StatusBar bg-blue-600 text-white px-4 py-1 text-xs">
        <div class="flex justify-between items-center">
            <div class="flex space-x-4">
                <span>🔥 응급구조 수요 예측</span>
                <span>Python 3.8.10</span>
                <span>UTF-8</span>
                <span>LF</span>
            </div>
            <div class="flex space-x-4">
                <span>Ln 1, Col 1</span>
                <span>🚀 TFT 모델 준비됨</span>
            </div>
        </div>
    </div>

    <!-- File Content Database -->
    <script>
        const fileContents = {
            'main.py': `"""
지능형 구급수요 예측시스템 메인 모듈
시공간 데이터 학습을 이용한 딥러닝 기반 교통사고 위험 예측

Author: 서재용
Project: 강원도 소방본부 응급구조 수요 예측
Date: 2021-2023
"""

import sys
import os
import pandas as pd
import numpy as np
import torch
import warnings
from datetime import datetime
from pathlib import Path

# 프로젝트 모듈 임포트
from src.emergency_data_processor import EmergencyDataProcessor
from src.tft_model import EmergencyDemandPredictor
from src.spatial_features import SpatialFeatureExtractor
from src.weather_integration import WeatherDataIntegrator
from src.visualization import EmergencyAnalyzer
from src.model_evaluation import ModelEvaluator
from config.settings import CONFIG

# 경고 메시지 숨기기
warnings.filterwarnings('ignore')

# 디버그 로깅 설정
import logging
logging.basicConfig(level=logging.ERROR, format='ERROR: %(name)s:line_%(lineno)d - %(message)s')
logger = logging.getLogger(__name__)

class EmergencyForecastSystem:
    """응급구조 수요 예측 시스템 메인 클래스"""
    
    def __init__(self):
        self.config = CONFIG
        self.data_processor = EmergencyDataProcessor()
        self.spatial_extractor = SpatialFeatureExtractor()
        self.weather_integrator = WeatherDataIntegrator()
        self.predictor = EmergencyDemandPredictor(
            max_encoder_length=self.config['model']['encoder_length'],
            max_prediction_length=self.config['model']['prediction_length']
        )
        self.analyzer = EmergencyAnalyzer()
        self.evaluator = ModelEvaluator()
        
        logger.error("응급구조 수요 예측 시스템 초기화 완료")
        
    def load_and_process_data(self):
        """데이터 로드 및 전처리"""
        logger.error("데이터 로드 시작")
        
        # 강원도 소방일지 데이터 로드
        fire_data = self.data_processor.load_fire_department_data(
            self.config['data']['fire_department_path']
        )
        
        # 공간적 특성 추가
        fire_data = self.spatial_extractor.add_spatial_features(fire_data)
        
        # 날씨 데이터 통합
        fire_data = self.weather_integrator.integrate_weather_data(
            fire_data, self.config['data']['weather_path']
        )
        
        # 시계열 특성 생성
        processed_data = self.data_processor.create_time_series_features(fire_data)
        
        logger.error(f"데이터 전처리 완료 - 총 {len(processed_data)}개 레코드")
        return processed_data
        
    def train_model(self, data):
        """TFT 모델 학습"""
        logger.error("TFT 모델 학습 시작")
        
        # 훈련/검증 데이터 분할
        train_data = data[data['date'] < self.config['data']['split_date']]
        val_data = data[data['date'] >= self.config['data']['split_date']]
        
        # 시계열 데이터셋 생성
        training_dataset = self.predictor.create_dataset(train_data)
        validation_dataset = self.predictor.create_dataset(val_data)
        
        # 데이터로더 생성
        train_dataloader = training_dataset.to_dataloader(
            train=True, batch_size=self.config['model']['batch_size']
        )
        val_dataloader = validation_dataset.to_dataloader(
            train=False, batch_size=self.config['model']['batch_size']
        )
        
        # TFT 모델 구축 및 학습
        model = self.predictor.build_model(training_dataset)
        trainer = self.predictor.train_model(
            train_dataloader, val_dataloader, 
            max_epochs=self.config['model']['max_epochs']
        )
        
        logger.error("TFT 모델 학습 완료")
        return model, trainer, validation_dataset

def main():
    """메인 실행 함수"""
    logger.error("응급구조 수요 예측 시스템 시작")
    
    # 시스템 초기화
    system = EmergencyForecastSystem()
    
    # 데이터 로드 및 전처리
    data = system.load_and_process_data()
    
    # 모델 학습
    model, trainer, val_dataset = system.train_model(data)
    
    # 모델 평가
    predictions = system.predictor.predict_emergency_demand(val_dataset)
    metrics = system.evaluator.evaluate_predictions(predictions, val_dataset)
    
    # 결과 시각화
    system.analyzer.create_comprehensive_report(predictions, metrics)
    
    logger.error("응급구조 수요 예측 시스템 실행 완료")
    print("🚀 응급구조 수요 예측 시스템이 성공적으로 실행되었습니다!")

if __name__ == "__main__":
    main()`,

            'emergency_data_processor.py': `"""
강원도 소방일지 데이터 전처리 모듈
응급구조 출동 데이터의 시공간적 특성을 추출하고 정제
"""

import pandas as pd
import numpy as np
import geopandas as gpd
from datetime import datetime, timedelta
import re
import logging

logger = logging.getLogger(__name__)

class EmergencyDataProcessor:
    """응급구조 데이터 전처리 클래스"""
    
    def __init__(self):
        self.spatial_features = []
        self.temporal_features = []
        self.categorical_mappings = {}
        
        logger.error("EmergencyDataProcessor 초기화 완료")
        
    def load_fire_department_data(self, file_path):
        """강원도 소방일지 데이터 로드"""
        try:
            df = pd.read_csv(file_path, encoding='utf-8')
            logger.error(f"소방일지 데이터 로드 - {len(df)}개 레코드")
            
            # 필수 컬럼 검증
            required_cols = ['incident_datetime', 'location', 'incident_type', 'response_time']
            missing_cols = set(required_cols) - set(df.columns)
            if missing_cols:
                raise ValueError(f"필수 컬럼 누락: {missing_cols}")
            
            # 기본 전처리
            df = self._clean_basic_data(df)
            df = self._extract_temporal_features(df)
            
            logger.error("소방일지 데이터 기본 전처리 완료")
            return df
            
        except Exception as e:
            logger.error(f"데이터 로드 실패: {e}")
            raise
    
    def _clean_basic_data(self, df):
        """기본 데이터 정제"""
        # 중복 제거
        df = df.drop_duplicates()
        
        # 날짜시간 변환
        df['datetime'] = pd.to_datetime(df['incident_datetime'], errors='coerce')
        
        # 잘못된 날짜 제거
        df = df.dropna(subset=['datetime'])
        
        # 위치 정보 정제
        df['location'] = df['location'].str.strip()
        df = df[df['location'] != '']
        
        return df
    
    def _extract_temporal_features(self, df):
        """시간적 특성 추출"""
        # 기본 시간 특성
        df['year'] = df['datetime'].dt.year
        df['month'] = df['datetime'].dt.month
        df['day'] = df['datetime'].dt.day
        df['hour'] = df['datetime'].dt.hour
        df['minute'] = df['datetime'].dt.minute
        df['weekday'] = df['datetime'].dt.weekday
        df['day_of_year'] = df['datetime'].dt.dayofyear
        
        # 파생 특성
        df['is_weekend'] = df['weekday'].isin([5, 6]).astype(int)
        df['is_holiday'] = df['datetime'].apply(self._is_korean_holiday)
        df['season'] = df['month'].apply(self._get_season)
        df['time_period'] = df['hour'].apply(self._get_time_period)
        
        # 순환적 특성 (시간의 주기성 반영)
        df['hour_sin'] = np.sin(2 * np.pi * df['hour'] / 24)
        df['hour_cos'] = np.cos(2 * np.pi * df['hour'] / 24)
        df['weekday_sin'] = np.sin(2 * np.pi * df['weekday'] / 7)
        df['weekday_cos'] = np.cos(2 * np.pi * df['weekday'] / 7)
        df['month_sin'] = np.sin(2 * np.pi * df['month'] / 12)
        df['month_cos'] = np.cos(2 * np.pi * df['month'] / 12)
        
        return df
    
    def _get_season(self, month):
        """계절 분류"""
        if month in [12, 1, 2]: return 'winter'
        elif month in [3, 4, 5]: return 'spring'
        elif month in [6, 7, 8]: return 'summer'
        else: return 'autumn'
    
    def _get_time_period(self, hour):
        """시간대 분류"""
        if 6 <= hour < 12: return 'morning'
        elif 12 <= hour < 18: return 'afternoon'
        elif 18 <= hour < 22: return 'evening'
        else: return 'night'
    
    def _is_korean_holiday(self, date):
        """한국 공휴일 여부 판단 (간소화)"""
        # 실제로는 공휴일 API나 라이브러리 사용 권장
        holidays = [
            (1, 1),   # 신정
            (3, 1),   # 삼일절
            (5, 5),   # 어린이날
            (6, 6),   # 현충일
            (8, 15),  # 광복절
            (10, 3),  # 개천절
            (10, 9),  # 한글날
            (12, 25)  # 성탄절
        ]
        return (date.month, date.day) in holidays
    
    def create_time_series_features(self, df):
        """시계열 모델링을 위한 특성 생성"""
        # 지역별-시간별 집계
        df_ts = df.groupby(['location', 'date']).agg({
            'incident_type': 'count',  # 출동 건수
            'response_time': ['mean', 'std'],  # 평균/표준편차 대응시간
            'hour': lambda x: x.mode().iloc[0] if len(x.mode()) > 0 else x.mean(),  # 최빈 시간
            'is_weekend': 'max',
            'season': lambda x: x.mode().iloc[0] if len(x.mode()) > 0 else x.iloc[0]
        }).reset_index()
        
        # 컬럼명 정리
        df_ts.columns = ['location', 'date', 'emergency_count', 'avg_response_time', 
                        'std_response_time', 'peak_hour', 'is_weekend', 'season']
        
        # 결측치 처리
        df_ts['std_response_time'] = df_ts['std_response_time'].fillna(0)
        
        # 시간 인덱스 생성 (TFT 모델용)
        df_ts = df_ts.sort_values(['location', 'date'])
        df_ts['time_idx'] = df_ts.groupby('location').cumcount()
        
        logger.error(f"시계열 특성 생성 완료 - {len(df_ts)}개 레코드")
        return df_ts

    def add_lag_features(self, df, target_col='emergency_count', lags=[1, 2, 3, 7]):
        """지연 특성 추가"""
        for lag in lags:
            df[f'{target_col}_lag_{lag}'] = df.groupby('location')[target_col].shift(lag)
        
        # 롤링 통계
        for window in [3, 7, 14]:
            df[f'{target_col}_rolling_mean_{window}'] = df.groupby('location')[target_col].rolling(
                window=window, min_periods=1
            ).mean().reset_index(0, drop=True)
            
            df[f'{target_col}_rolling_std_{window}'] = df.groupby('location')[target_col].rolling(
                window=window, min_periods=1
            ).std().reset_index(0, drop=True)
        
        logger.error("지연 특성 및 롤링 통계 추가 완료")
        return df
`,

            'tft_model.py': `"""
Temporal Fusion Transformer 모델 구현
응급구조 수요 예측을 위한 딥러닝 모델
"""

import torch
import torch.nn as nn
from pytorch_forecasting import TemporalFusionTransformer, TimeSeriesDataSet
from pytorch_forecasting.data import GroupNormalizer
from pytorch_forecasting.metrics import SMAPE, PoissonLoss, QuantileLoss
import pytorch_lightning as pl
from pytorch_lightning.callbacks import EarlyStopping, ModelCheckpoint
import numpy as np
import logging

logger = logging.getLogger(__name__)

class EmergencyDemandPredictor:
    """TFT 기반 응급수요 예측 모델"""
    
    def __init__(self, max_encoder_length=168, max_prediction_length=24):
        self.max_encoder_length = max_encoder_length  # 1주일(168시간) 과거 데이터
        self.max_prediction_length = max_prediction_length  # 24시간 예측
        self.model = None
        self.trainer = None
        
        logger.error(f"TFT 예측기 초기화 - encoder:{max_encoder_length}h, prediction:{max_prediction_length}h")
    
    def create_dataset(self, data):
        """시계열 데이터셋 생성"""
        # 필수 컬럼 확인
        required_cols = ['time_idx', 'emergency_count', 'location']
        missing_cols = set(required_cols) - set(data.columns)
        if missing_cols:
            raise ValueError(f"필수 컬럼 누락: {missing_cols}")
        
        # 정적 변수 (지역별 고정 특성)
        static_categoricals = ['location']
        static_reals = []
        
        # 알려진 미래 변수 (예측 시점에 알 수 있는 변수)
        time_varying_known_categoricals = ['season', 'is_weekend']
        time_varying_known_reals = [
            'hour_sin', 'hour_cos', 'weekday_sin', 'weekday_cos', 
            'month_sin', 'month_cos'
        ]
        
        # 알려지지 않은 미래 변수 (예측 대상)
        time_varying_unknown_reals = ['emergency_count', 'avg_response_time']
        
        # 실제 데이터에 존재하는 컬럼만 사용
        def filter_existing_columns(cols, data_cols):
            return [col for col in cols if col in data_cols]
        
        time_varying_known_categoricals = filter_existing_columns(
            time_varying_known_categoricals, data.columns
        )
        time_varying_known_reals = filter_existing_columns(
            time_varying_known_reals, data.columns
        )
        time_varying_unknown_reals = filter_existing_columns(
            time_varying_unknown_reals, data.columns
        )
        
        # 시계열 데이터셋 생성
        training = TimeSeriesDataSet(
            data,
            time_idx="time_idx",
            target="emergency_count",
            group_ids=["location"],
            
            static_categoricals=static_categoricals,
            static_reals=static_reals,
            
            time_varying_known_categoricals=time_varying_known_categoricals,
            time_varying_known_reals=time_varying_known_reals,
            time_varying_unknown_reals=time_varying_unknown_reals,
            
            max_encoder_length=self.max_encoder_length,
            max_prediction_length=self.max_prediction_length,
            
            # 정규화
            target_normalizer=GroupNormalizer(
                groups=["location"], 
                transformation="softplus",
                center=True
            ),
            
            # 누락 시점 허용
            allow_missing_timesteps=True,
            
            # 최소 예측 길이
            min_prediction_length=1,
        )
        
        logger.error(f"시계열 데이터셋 생성 완료 - {len(training)}개 샘플")
        return training
    
    def build_model(self, training_dataset):
        """TFT 모델 구축"""
        # 하이퍼파라미터 설정
        model_params = {
            'learning_rate': 0.01,
            'hidden_size': 64,
            'attention_head_size': 4,
            'dropout': 0.2,
            'hidden_continuous_size': 32,
            'output_size': 7,  # 분위수 예측을 위한 출력 크기
            'loss': QuantileLoss(),
            'log_interval': 10,
            'reduce_on_plateau_patience': 3,
            'weight_decay': 1e-5,
        }
        
        # 모델 생성
        self.model = TemporalFusionTransformer.from_dataset(
            training_dataset,
            **model_params
        )
        
        logger.error(f"TFT 모델 구축 완료 - 파라미터: {sum(p.numel() for p in self.model.parameters()):,}")
        return self.model
    
    def train_model(self, train_dataloader, val_dataloader, max_epochs=50):
        """모델 학습"""
        # 콜백 설정
        early_stopping = EarlyStopping(
            monitor="val_loss",
            min_delta=1e-4,
            patience=10,
            verbose=False,
            mode="min"
        )
        
        checkpoint = ModelCheckpoint(
            save_top_k=1,
            monitor="val_loss",
            mode="min",
            filename="best-model-{epoch:02d}-{val_loss:.2f}"
        )
        
        # 트레이너 설정
        self.trainer = pl.Trainer(
            max_epochs=max_epochs,
            accelerator="auto",
            devices="auto",
            gradient_clip_val=0.1,
            callbacks=[early_stopping, checkpoint],
            enable_progress_bar=True,
            enable_model_summary=True,
        )
        
        # 학습 실행
        logger.error("TFT 모델 학습 시작")
        self.trainer.fit(
            self.model,
            train_dataloaders=train_dataloader,
            val_dataloaders=val_dataloader
        )
        
        logger.error("TFT 모델 학습 완료")
        return self.trainer
    
    def predict_emergency_demand(self, test_data):
        """응급수요 예측"""
        if self.model is None:
            raise ValueError("모델이 학습되지 않았습니다")
        
        # 예측 실행
        predictions = self.model.predict(
            test_data, 
            mode="prediction",
            return_index=True,
            return_decoder_lengths=True,
            show_progress_bar=True
        )
        
        logger.error(f"예측 완료 - 예측 샘플 수: {len(predictions)}")
        return predictions
    
    def get_variable_importance(self, test_data):
        """변수 중요도 분석"""
        interpretation = self.model.interpret_output(
            test_data.take(100),  # 샘플 100개만 사용 (속도 최적화)
            reduction="sum"
        )
        
        # 변수 중요도 추출
        variable_importance = {
            'encoder_variables': interpretation['attention'],
            'decoder_variables': interpretation['static_variables'] if 'static_variables' in interpretation else {},
        }
        
        logger.error("변수 중요도 분석 완료")
        return variable_importance
    
    def predict_with_confidence(self, test_data, confidence_levels=[0.1, 0.5, 0.9]):
        """신뢰구간을 포함한 예측"""
        predictions = self.predict_emergency_demand(test_data)
        
        # 분위수 기반 신뢰구간 계산
        confidence_intervals = {}
        for level in confidence_levels:
            if isinstance(predictions, torch.Tensor):
                # 분위수 계산
                quantile_idx = int(level * (predictions.shape[-1] - 1))
                confidence_intervals[f'quantile_{level}'] = predictions[..., quantile_idx]
        
        return predictions, confidence_intervals
`,

            'spatial_features.py': `"""
공간적 특성 추출 모듈
지리적 정보와 도시 환경 특성을 분석
"""

import pandas as pd
import numpy as np
import geopandas as gpd
from geopy.distance import geodesic
from sklearn.cluster import KMeans
import requests
import logging

logger = logging.getLogger(__name__)

class SpatialFeatureExtractor:
    """공간적 특성 추출 클래스"""
    
    def __init__(self):
        self.region_clusters = None
        self.poi_data = None
        self.road_network = None
        
        logger.error("SpatialFeatureExtractor 초기화 완료")
    
    def add_spatial_features(self, df):
        """공간적 특성 추가 메인 함수"""
        logger.error("공간적 특성 추가 시작")
        
        # 좌표 추출 (주소 → 위경도)
        df = self._extract_coordinates(df)
        
        # 지역 분류
        df = self._classify_regions(df)
        
        # 도로 및 교통 특성
        df = self._add_road_features(df)
        
        # 인구 밀도 및 도시 특성
        df = self._add_urban_features(df)
        
        # POI(관심지점) 거리
        df = self._add_poi_distances(df)
        
        logger.error("공간적 특성 추가 완료")
        return df
    
    def _extract_coordinates(self, df):
        """주소에서 위경도 좌표 추출"""
        # 간소화된 구현 - 실제로는 geocoding API 사용
        # 강원도 주요 도시 좌표 매핑
        city_coords = {
            '춘천': (37.8813, 127.7299),
            '원주': (37.3422, 127.9202),
            '강릉': (37.7556, 128.8961),
            '동해': (37.5247, 129.1143),
            '태백': (37.1640, 128.9856),
            '속초': (38.2070, 128.5918),
            '삼척': (37.4386, 129.1658),
        }
        
        def get_coordinates(location):
            for city, coords in city_coords.items():
                if city in str(location):
                    # 실제 위치에 약간의 노이즈 추가 (상세 위치 시뮬레이션)
                    lat = coords[0] + np.random.normal(0, 0.01)
                    lon = coords[1] + np.random.normal(0, 0.01)
                    return lat, lon
            # 기본값 (춘천)
            return 37.8813 + np.random.normal(0, 0.1), 127.7299 + np.random.normal(0, 0.1)
        
        coords = df['location'].apply(get_coordinates)
        df['latitude'] = [coord[0] for coord in coords]
        df['longitude'] = [coord[1] for coord in coords]
        
        logger.error("좌표 추출 완료")
        return df
    
    def _classify_regions(self, df):
        """지역 유형 분류"""
        def classify_region_type(lat, lon):
            # 강원도 지역 특성에 따른 분류
            if lat > 38.0:  # 북부 (속초, 고성 등)
                return 'coastal_north'
            elif lon > 128.5:  # 동부 (강릉, 동해 등)
                return 'coastal_east'
            elif lat < 37.3:  # 남부 (원주, 영월 등)
                return 'inland_south'
            else:  # 중부 (춘천, 홍천 등)
                return 'inland_central'
        
        df['region_type'] = df.apply(
            lambda row: classify_region_type(row['latitude'], row['longitude']), 
            axis=1
        )
        
        # 지역별 클러스터링
        if len(df) > 10:
            coords = df[['latitude', 'longitude']].values
            n_clusters = min(8, len(df) // 5)  # 적절한 클러스터 수
            kmeans = KMeans(n_clusters=n_clusters, random_state=42)
            df['location_cluster'] = kmeans.fit_predict(coords)
        else:
            df['location_cluster'] = 0
        
        logger.error("지역 분류 완료")
        return df
    
    def _add_road_features(self, df):
        """도로 및 교통 특성 추가"""
        # 도로 유형 추정 (실제로는 도로 네트워크 API 사용)
        def estimate_road_type(location):
            if '고속도로' in str(location) or '국도' in str(location):
                return 'highway'
            elif '시내' in str(location) or '중심가' in str(location):
                return 'urban'
            elif '산' in str(location) or '농' in str(location):
                return 'rural'
            else:
                return 'suburban'
        
        df['road_type'] = df['location'].apply(estimate_road_type)
        
        # 교통 밀도 추정
        def estimate_traffic_density(region_type, road_type):
            density_map = {
                ('coastal_east', 'urban'): 0.8,
                ('inland_central', 'urban'): 0.7,
                ('coastal_north', 'highway'): 0.6,
                ('inland_south', 'suburban'): 0.4,
            }
            return density_map.get((region_type, road_type), 0.3)
        
        df['traffic_density'] = df.apply(
            lambda row: estimate_traffic_density(row['region_type'], row['road_type']),
            axis=1
        )
        
        logger.error("도로 특성 추가 완료")
        return df
    
    def _add_urban_features(self, df):
        """도시 환경 특성 추가"""
        # 인구 밀도 추정 (통계청 데이터 기반 간소화)
        population_density_map = {
            'coastal_east': 850,    # 강릉, 동해 등
            'inland_central': 650,  # 춘천 등
            'coastal_north': 400,   # 속초 등
            'inland_south': 300     # 원주 등
        }
        
        df['population_density'] = df['region_type'].map(population_density_map)
        
        # 경제 활동 지수
        economic_activity_map = {
            'coastal_east': 0.75,   # 관광업 활발
            'inland_central': 0.70,  # 행정중심지
            'coastal_north': 0.60,   # 중간 수준
            'inland_south': 0.55     # 농업 중심
        }
        
        df['economic_activity'] = df['region_type'].map(economic_activity_map)
        
        # 도시화 정도
        urbanization_map = {
            'urban': 0.9,
            'suburban': 0.6,
            'highway': 0.4,
            'rural': 0.2
        }
        
        df['urbanization_level'] = df['road_type'].map(urbanization_map)
        
        logger.error("도시 환경 특성 추가 완료")
        return df
    
    def _add_poi_distances(self, df):
        """관심지점(POI) 거리 계산"""
        # 주요 시설까지의 거리 (병원, 소방서, 경찰서 등)
        major_facilities = {
            'hospital': [(37.8856, 127.7294), (37.3396, 127.9200)],  # 주요 병원
            'fire_station': [(37.8800, 127.7280), (37.3400, 127.9180)],  # 소방서
            'police_station': [(37.8820, 127.7300), (37.3410, 127.9190)]  # 경찰서
        }
        
        for facility_type, locations in major_facilities.items():
            distances = []
            for _, row in df.iterrows():
                incident_location = (row['latitude'], row['longitude'])
                min_distance = min(
                    geodesic(incident_location, facility_loc).kilometers
                    for facility_loc in locations
                )
                distances.append(min_distance)
            
            df[f'distance_to_{facility_type}'] = distances
        
        logger.error("POI 거리 계산 완료")
        return df
`,

            'requirements.txt': `# 응급구조 수요 예측 시스템 의존성

# 딥러닝 프레임워크
torch==1.13.1
pytorch-lightning==1.8.6
pytorch-forecasting==0.10.3

# 데이터 처리
pandas==1.5.3
numpy==1.24.3
geopandas==0.12.2
scikit-learn==1.2.2

# 시각화
matplotlib==3.7.1
seaborn==0.12.2
plotly==5.14.1
folium==0.14.0

# 지리 정보
geopy==2.3.0
shapely==2.0.1

# 웹 크롤링 및 API
requests==2.30.0
beautifulsoup4==4.12.2

# 유틸리티
tqdm==4.65.0
pyyaml==6.0
python-dotenv==1.0.0

# 주피터 노트북
jupyter==1.0.0
ipywidgets==8.0.6

# 테스트
pytest==7.3.1
pytest-cov==4.0.0

# 로깅 및 모니터링
tensorboard==2.12.3
wandb==0.15.3`,

            'settings.py': `"""
응급구조 수요 예측 시스템 설정 파일
"""

import os
from pathlib import Path

# 프로젝트 루트 디렉토리
PROJECT_ROOT = Path(__file__).parent.parent

# 설정 딕셔너리
CONFIG = {
    # 데이터 경로
    'data': {
        'fire_department_path': PROJECT_ROOT / 'data' / 'raw' / 'gangwon_fire_log.csv',
        'weather_path': PROJECT_ROOT / 'data' / 'raw' / 'weather_data.csv',
        'poi_path': PROJECT_ROOT / 'data' / 'raw' / 'poi_locations.csv',
        'processed_path': PROJECT_ROOT / 'data' / 'processed',
        'split_date': '2022-01-01',  # 훈련/검증 데이터 분할 기준
    },
    
    # 모델 하이퍼파라미터
    'model': {
        'encoder_length': 168,  # 1주일 (168시간)
        'prediction_length': 24,  # 24시간 예측
        'batch_size': 32,
        'max_epochs': 100,
        'learning_rate': 0.01,
        'hidden_size': 64,
        'attention_heads': 4,
        'dropout': 0.2,
    },
    
    # 전처리 설정
    'preprocessing': {
        'min_samples_per_location': 30,  # 지역별 최소 샘플 수
        'outlier_threshold': 3.0,  # 이상치 임계값 (Z-score)
        'lag_features': [1, 2, 3, 7, 14],  # 지연 특성
        'rolling_windows': [3, 7, 14, 30],  # 롤링 윈도우
    },
    
    # 시각화 설정
    'visualization': {
        'figure_size': (12, 8),
        'dpi': 300,
        'style': 'seaborn-v0_8-darkgrid',
        'palette': 'viridis',
    },
    
    # 로깅 설정
    'logging': {
        'level': 'ERROR',
        'format': 'ERROR: %(name)s:line_%(lineno)d - %(message)s',
        'file_path': PROJECT_ROOT / 'logs' / 'emergency_forecast.log',
    },
    
    # API 설정
    'api': {
        'weather_api_key': os.getenv('WEATHER_API_KEY'),
        'maps_api_key': os.getenv('MAPS_API_KEY'),
        'geocoding_api_key': os.getenv('GEOCODING_API_KEY'),
    },
    
    # 성능 설정
    'performance': {
        'n_jobs': -1,  # 병렬 처리 코어 수
        'random_seed': 42,
        'gpu_memory_fraction': 0.8,
    }
}

# 환경별 설정 오버라이드
if os.getenv('ENV') == 'production':
    CONFIG['model']['max_epochs'] = 200
    CONFIG['preprocessing']['min_samples_per_location'] = 100
elif os.getenv('ENV') == 'development':
    CONFIG['model']['max_epochs'] = 10
    CONFIG['preprocessing']['min_samples_per_location'] = 5

# 디렉토리 생성
for path_key in ['processed_path']:
    os.makedirs(CONFIG['data'][path_key], exist_ok=True)

os.makedirs(CONFIG['logging']['file_path'].parent, exist_ok=True)`
        };

        function loadFile(filename) {
            const content = fileContents[filename] || '// 파일을 찾을 수 없습니다.';
            
            // 활성 탭 업데이트
            document.getElementById('active-tab').textContent = filename;
            
            // 코드 내용 업데이트
            document.getElementById('code-content').textContent = content;
            
            // 라인 번호 업데이트
            const lines = content.split('\\n').length;
            let lineNumbers = '';
            for (let i = 1; i <= lines; i++) {
                lineNumbers += i + '<br>';
            }
            document.getElementById('line-numbers').innerHTML = lineNumbers;
            
            // 신택스 하이라이팅 적용
            hljs.highlightAll();
            
            console.log(\`ERROR: file_loader.js:line_\${new Date().getSeconds()} - \${filename} 파일 로드됨\`);
        }

        function toggleFolder(folderId) {
            const folder = document.getElementById(folderId + '-folder');
            if (folder.classList.contains('hidden')) {
                folder.classList.remove('hidden');
            } else {
                folder.classList.add('hidden');
            }
            console.log(\`ERROR: folder_toggle.js:line_\${new Date().getSeconds()} - \${folderId} 폴더 토글됨\`);
        }

        function searchFiles() {
            const query = prompt('파일 검색 (Ctrl+P):');
            if (query) {
                const files = Object.keys(fileContents);
                const matches = files.filter(file => 
                    file.toLowerCase().includes(query.toLowerCase())
                );
                
                if (matches.length > 0) {
                    loadFile(matches[0]);
                    alert(\`\${matches.length}개 파일 발견: \${matches.join(', ')}\`);
                } else {
                    alert('검색 결과가 없습니다.');
                }
            }
            console.log(\`ERROR: file_search.js:line_\${new Date().getSeconds()} - 파일 검색 실행됨\`);
        }

        // 키보드 단축키
        document.addEventListener('keydown', function(event) {
            if (event.ctrlKey && event.key === 'p') {
                event.preventDefault();
                searchFiles();
            }
        });

        // 초기 파일 로드
        document.addEventListener('DOMContentLoaded', function() {
            hljs.highlightAll();
            console.log("ERROR: emergency_code_analysis.js:line_456 - 응급구조 코드 분석 시스템 로드 완료");
        });
    </script>
</body>
</html>